What is Object-Oriented Programming (OOP) in Python?

Object-Oriented Programming (OOP) is a programming paradigm that organizes code around objects rather than functions and procedures. In Python, everything is an object, making it a natural fit for OOP. OOP promotes code reusability, modularity, and maintainability by modeling real-world entities as objects that have attributes (data) and methods (behaviors).

Key Concepts of OOP
Python supports four main pillars of OOP:
Key Concepts of OOPKey Concepts of OOPcfvidfv
1. Encapsulation: Bundling data (attributes) and methods that operate on that data within a single unit (class), while restricting direct access to some components (e.g., using private attributes with _ or __ prefixes).
   
2. Inheritance: Allowing a new class (child/subclass) to inherit attributes and methods from an existing class (parent/superclass), promoting code reuse.

3. Polymorphism: Enabling objects of different classes to be treated as instances of the same class through a common interface (e.g., method overriding or duck typing).

4. Abstraction: Hiding complex implementation details and exposing only essential features (often achieved via abstract base classes).

Basic Syntax: Defining a Class and Creating Objects
A class is a blueprint for creating objects. An object (or instance) is a concrete realization of that blueprint.

# Defining a simple class
class Dog:
    # Constructor method (initializer)
    def __init__(self, name, age):
        self.name = name  # Attribute
        self.age = age    # Attribute
    
    # Method0
    def bark(self):
        return f"{self.name} says Woof!"

# Creating objects (instances)
dog1 = Dog("Buddy", 3)
dog2 = Dog("Max", 5)

print(dog1.bark())  # Output: Buddy says Woof!
print(dog2.name)    # Output: Max

Here:
- __init__ is the constructor, called automatically when creating an object.
- self refers to the instance itself (like this in other languages).

Example 1: Encapsulation
Encapsulation protects data by making attributes private (conventionally with __ prefix) and providing controlled access via methods.

class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance  # Private attribute
    
    # Getter method
    def get_balance(self):
        return self.__balance
    
    # Setter method
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return f"Deposited ${amount}. New balance: ${self.__balance}"
        return "Invalid deposit amount"
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return f"Withdrew ${amount}. New balance: ${self.__balance}"
        return "Invalid withdrawal amount"

# Usage
account = BankAccount("Alice", 1000)
print(account.deposit(500))  # Output: Deposited $500. New balance: $1500
print(account.get_balance()) # Output: 1500
# print(account.__balance)   # This would raise an AttributeError (encapsulated)

Example 2: Inheritance
A child class inherits from a parent class using (ParentClass).

# Parent class
class Animal:
    def __init__(self, name):
        self.name = name
    
    def eat(self):
        return f"{self.name} is eating."

# Child class inheriting from Animal
class Cat(Animal):
    def __init__(self, name, color):
        super().__init__(name)  # Call parent's constructor
        self.color = color
    
    # Override parent's method (polymorphism)
    def eat(self):
        return f"{self.name} (a {self.color} cat) is eating fish."

# Usage
animal = Animal("Generic")
cat = Cat("Whiskers", "tabby")

print(animal.eat())  # Output: Generic is eating.
print(cat.eat())     # Output: Whiskers (a tabby cat) is eating fish.

Example 3: Polymorphism
Different classes can implement the same method name differently, allowing uniform treatment.

class Bird:
    def speak(self):
        return "Tweet!"

class Dog:
    def speak(self):
        return "Woof!"

# Polymorphic function
def make_animal_speak(animal):
    return animal.speak()

# Usage
bird = Bird()
dog = Dog()

print(make_animal_speak(bird))  # Output: Tweet!
print(make_animal_speak(dog))    # Output: Woof!

Example 4: Abstraction (Using Abstract Base Classes)
Use abc module to define abstract classes that force subclasses to implement certain methods.

from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass  # Must be implemented by subclasses
    
    def description(self):  # Concrete method
        return "This is a shape."

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

# Usage
rect = Rectangle(5, 3)
print(rect.area())         # Output: 15
print(rect.description())  # Output: This is a shape.

# shape = Shape()  # This would raise TypeError (abstract class can't be instantiated)

These examples demonstrate how OOP in Python makes code more intuitive and scalable. For deeper dives, experiment with class methods (@classmethod), static methods (@staticmethod), or properties (@property). If you have a specific aspect you'd like more examples on, let me know!